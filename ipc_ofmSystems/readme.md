1) 실행 흐름
-ssu_ofm은 공유파일을 관리한다. 그리고 관리시에 생기는 정보를 log에 기록해준다. 
-ssu_ofm은 공유파일의 요청이 vim으로부터 오면 공유파일의 lock을 검사하고 사용 허가를 내려준다.
-ssu_ofm은 공유파일이 사용 중일 경우 사용 요청이 들어온 ssu_ofm을 큐에 넣고 사용 완료를 알리는 신호가 오면 순서대로 허가를 내준다. 
-ssu_vim은 ssu_ofm으로부터 공유파일의 사용 허가를 받으면 공유파일에 접근해서 공유파일을 이용한다. 이용이 끝나면 사용 완료를 ssu_ofm에 알려준다.
2) 구조설계
(1)	ssu_ofm
-ofm은 공유 파일의 관리를 해주는 프로세스로 데몬 프로세스를 생성한다.
-공유 파일을 요청하는 ssu_vim이 sigusr1을 보낸다면 공유파일의 잠금상태를 확인한 뒤 잠겨 있지 않다면 사용허가를 나타내는 sigusr1을 sigusr1을 보낸 프로세스에게 다시 보내준다.
-공유파일이 잠겨 있다면 sigusr1을 요청한 프로세스의 pid를 que에 넣어서 대기시킨다.
-ssu_ofm이 ssu_vim으로부터 공유파일의 사용 완료를 의미하는 sigusr2를 받는다면 큐에 저장되 있는 pid를 꺼내 sigusr1을 보내준다.
-signal1과 signal2를 받으면 로그에 정보를 기록해준다. 이때 프로세스의 pid와 요청한 파일 정보를 기록해준다.
-옵션에 따라서 동작이 달라진다.
-l의 경우에는 sigusr2를 받을 때마다 받은 시각에 해당하는 로그 파일을 별도로 만들어준다. 별도로 작성되는 로그 파일의 내용은 sigusr2를 보낸 프로세스의 sigusr1을 보냈을 때 기록된 로그 내용을 적어준다. 이때 아래의 옵션의 정보까지 모두 중복되게 작성된다.
-t의 경우에는 log에 signal을 받을 때마다 기존의 정보 이외에 시간 값을 추가해준다.
-n의 경우에는 현재 사용 중 일 때 pid를 넣는 큐의 사이즈를 설정해준다.
-p의 경우에는 log들이 생성되는 위치를 받은 인자로 설정해준다.
-id의 경우에는 sigusr1을 보낸 프로세스의 username, uid, gid 정보를 로그에 추가해준다. 
(2)	ssu_vim
-vim은 ofm에게 파일의 사용을 요청하는 프로세스이다. vim은 ofm이 실행 중에만 실행 가능하며 ofm에서 관리중인 공유 파일에 대해서만 읽기 쓰기가 가능하다.
-파일에 대해서 읽기를 요청한다면 ofm에게 어떤 시그널도 보내지 않고 바로 내용을 읽는다.
-파일에 대해서 쓰기를 요청한다면 FIFO파일에 요청할 파일의 이름을 기록해준다.
-그리고 동작하는 ofm프로세스에게 sigusr1을 보낸 뒤 기다린다는 문구를 1초 간격으로 출력한다 그리고 sigusr1을 ofm으로부터 다시 받았을 때 파일에 lock을 건 뒤 쓰기를 시작한다. 파일에 대한 쓰기가 끝났다면 파일의 lock을 해제한 뒤 다시 ofm에게 sigusr2를 보낸다.
-옵션에 따른 동작은 다음과 같다.
-옵션 t의 경우에는 파일에 대한 수정시간을 보여준다. 대기중 문구에도 현재시간을 1초간격으로 보여준다. 파일에 대한 사용이 끝난 후에 만약 수정이 있었는지 없었는지에 대한 문구를 보여준다.
-옵션 s의 경우에는 파일 수정 전 파일의 크기와 파일의 수정이 끝난 뒤의 파일 크기를 보여준다 
-옵션 d의 경우에는 파일 수정이 끝난 뒤 diff 명령어를 이용하여 파일의 수정 부분을 보여준다.

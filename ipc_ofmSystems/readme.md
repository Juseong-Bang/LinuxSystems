1) 실행 흐름
-ssu_ofm은 공유파일을 관리한다. 그리고 관리시에 생기는 정보를 log에 기록해준다. 
-ssu_ofm은 공유파일의 요청이 vim으로부터 오면 공유파일의 lock을 검사하고 사용 허가를 내려준다.
-ssu_ofm은 공유파일이 사용 중일 경우 사용 요청이 들어온 ssu_ofm을 큐에 넣고 사용 완료를 알리는 신호가 오면 순서대로 허가를 내준다. 
-ssu_vim은 ssu_ofm으로부터 공유파일의 사용 허가를 받으면 공유파일에 접근해서 공유파일을 이용한다. 이용이 끝나면 사용 완료를 ssu_ofm에 알려준다.
2) 구조설계
(1)	ssu_ofm
-ofm은 공유 파일의 관리를 해주는 프로세스로 데몬 프로세스를 생성한다.
-공유 파일을 요청하는 ssu_vim이 sigusr1을 보낸다면 공유파일의 잠금상태를 확인한 뒤 잠겨 있지 않다면 사용허가를 나타내는 sigusr1을 sigusr1을 보낸 프로세스에게 다시 보내준다.
-공유파일이 잠겨 있다면 sigusr1을 요청한 프로세스의 pid를 que에 넣어서 대기시킨다.
-ssu_ofm이 ssu_vim으로부터 공유파일의 사용 완료를 의미하는 sigusr2를 받는다면 큐에 저장되 있는 pid를 꺼내 sigusr1을 보내준다.
-signal1과 signal2를 받으면 로그에 정보를 기록해준다. 이때 프로세스의 pid와 요청한 파일 정보를 기록해준다.
-옵션에 따라서 동작이 달라진다.
-l의 경우에는 sigusr2를 받을 때마다 받은 시각에 해당하는 로그 파일을 별도로 만들어준다. 별도로 작성되는 로그 파일의 내용은 sigusr2를 보낸 프로세스의 sigusr1을 보냈을 때 기록된 로그 내용을 적어준다. 이때 아래의 옵션의 정보까지 모두 중복되게 작성된다.
-t의 경우에는 log에 signal을 받을 때마다 기존의 정보 이외에 시간 값을 추가해준다.
-n의 경우에는 현재 사용 중 일 때 pid를 넣는 큐의 사이즈를 설정해준다.
-p의 경우에는 log들이 생성되는 위치를 받은 인자로 설정해준다.
-id의 경우에는 sigusr1을 보낸 프로세스의 username, uid, gid 정보를 로그에 추가해준다. 
(2)	ssu_vim
-vim은 ofm에게 파일의 사용을 요청하는 프로세스이다. vim은 ofm이 실행 중에만 실행 가능하며 ofm에서 관리중인 공유 파일에 대해서만 읽기 쓰기가 가능하다.
-파일에 대해서 읽기를 요청한다면 ofm에게 어떤 시그널도 보내지 않고 바로 내용을 읽는다.
-파일에 대해서 쓰기를 요청한다면 FIFO파일에 요청할 파일의 이름을 기록해준다.
-그리고 동작하는 ofm프로세스에게 sigusr1을 보낸 뒤 기다린다는 문구를 1초 간격으로 출력한다 그리고 sigusr1을 ofm으로부터 다시 받았을 때 파일에 lock을 건 뒤 쓰기를 시작한다. 파일에 대한 쓰기가 끝났다면 파일의 lock을 해제한 뒤 다시 ofm에게 sigusr2를 보낸다.
-옵션에 따른 동작은 다음과 같다.
-옵션 t의 경우에는 파일에 대한 수정시간을 보여준다. 대기중 문구에도 현재시간을 1초간격으로 보여준다. 파일에 대한 사용이 끝난 후에 만약 수정이 있었는지 없었는지에 대한 문구를 보여준다.
-옵션 s의 경우에는 파일 수정 전 파일의 크기와 파일의 수정이 끝난 뒤의 파일 크기를 보여준다 
-옵션 d의 경우에는 파일 수정이 끝난 뒤 diff 명령어를 이용하여 파일의 수정 부분을 보여준다.

-main() : 데몬 프로세서를 만들기전에 현재 경로를 curpath에 저장하고 로그의 절대경로를 logpath에 저장하고 공유파일의 절대경로는 shareFile에 저장한다. 그리고 공유파일이 존재하지 않는다면 공유파일을 만들어준다.
-옵션 검사를 해준다
-데몬 프로세서를 호출한다.
-로그에 시작 문장을 작성해준다. 데몬 프로세스의 pid , 옵션 n에 따라서 설정된 que의 사이즈 옵션 t에 따라서 현재 시간을 써준다.
-옵션 l을 사용했다면 이 모든 문장을 전역변수에 저장해준다.
-이후 무한루프를 돌며 sigusr1과 sigusr2를 기다린다.


-sig_usr1(): SIGUSR1 시그널에 사용할 handler 이다. usr1 시그널을 vim 으로부터 받으면 실행된다.
-기본 동작은 FIFO파일을 열어서 현재 vim이 요구한 파일의 이름을 가져온다. 그리고 그 파일이 공유파일과 같다면 공유파일의 lock을 검사한다. lock이 걸려있다면 큐의 사이즈를 확인한 뒤 공간이 있다면 큐에 sigusr1을 보낸 프로세스의 pid를 siginfo_t 구조체에서 가져와서 넣어준다. 만약 파일에 lock이 걸려있지 않다면 sigusr1을 보낸 프로세스의 pid를 siginfo_t 구조체에서 가져와서 sigusr1 시그널을 보낸다.
-option의 여부에 따라서 세부동작이 추가된다. l, t, id옵션에 따라서 동작이 추가된다.
-l 옵션의 경우 log에 작성되는 모든 내용을 linebuf에 저장한뒤 큐에 넣어둔다. 이정보는 sigusr2를 받는 핸들러에서 꺼내 쓴다.
-t 옵션의 경우 log에 시간 정보를 저장해야 하므로 time함수를 이용해 sigusr1을 받았을때의 시간을 time_t 구조체에 저장한뒤 strftime 함수를 이용해서 [yyyy-mm-dd hh-mm-s] 형태로 저장한뒤 로그파일에 써준다.
-id 옵션의 경우 siginfo_t의 정보중 uid를 가져온 뒤 getpwid()를 이용해서 pwd 구조체를 가져온다. 이 pwd 구조체에는 username, uid, gid등의 정보가 들어있으므로 이를 log에 써준다.

- sig_usr2(): SIGUSR2 시그널에 사용할 handler 이다. usr2 시그널을 vim 으로부터 받으면 실행된다.
-SIGUSR2를 받으면 siginfo_t 구조체에서 pid값을 받아와서 log에 기록해준다. 그리고 que가 비어있지 않다면 que에서 pid를 꺼내서 해당 프로세스에 SIGUSR1을 보내 공유파일에 대한 사용허가를 내준다.
-옵션에 l, t에 따른 세부 동작이 있다.
-옵션 l은 새로운 로그 파일이 만들어져야 하므로 전역변수에 저장된 init 문장과 별도로 큐에 저장되어 있던 sigusr1을 받을 때 생성된 로그 메시지와 sigusr2를 받을 때 생성된 문장, 이렇게 3가지 정보를 같이 sigusr2를 받은 시점을 파일명으로 하는 로그에 저장해준다. 
- t 옵션의 경우 log에 시간 정보를 저장해야 하므로 time함수를 이용해 sigusr1을 받았을때의 시간을 time_t 구조체에 저장한뒤 strftime 함수를 이용해서 [yyyy-mm-dd hh-mm-s] 형태로 저장한뒤 로그파일에 써준다.

-init() : 데몬 프로세서 호출과 각종 초기화를 진행한다.
-SIGTERM의 핸들러를 signal()을 이용해서 등록한다. SIGUSR1과 SIGUSR2의 핸들러는 siginfo_t를 필요로 하므로 SA_SIGINFO 플래그를 설정해준뒤 sigaction()을 이용해서 등록한다.
-이후 로그파일이 존재하면 지워준뒤 다시 생성해주고 FIFO 파일 또한 존재한다면 지워준뒤 다시 생성해준다. SIGUSR1을 기다리는 vim의 pid를 저장하는 큐의 key와 큐를 생성한다. option l 사용시 sigusr1을 받았을 때 생성 되는 로그 메시지를 저장해두는 용도로 사용하는 큐의 key와 큐도 생성 해준다.

-checkLock() : 공유파일의 lock을 검사하는 함수이다. ofm이 sigusr1을 받으면 실행되는 핸들러에서 호출한다. 락이 걸려있다면 -1을 걸려있지 않다면 0을 리턴한다.
-공유파일의 디스크립터를 가져온뒤 struct flock 구조체에 cntl을 이용해서 파일의 lock에 대한 정보를 가지고 온다. flock 구조체의 ltype에 파일의 잠금에 대한 잠금 정보가 들어있다. 이를 이용해서 0또는 -1을 리턴해준다.

checkOpt():ofm의 option을 구분 하고 체크해주는 함수이다.
opt[]에 각각의 option l, t, n, p, id 가 올 때 그 옵션이 사용됨을 체크해주고 n과 p옵션에 있어서 뒤에 오는 인자를 적용해준다.
-n옵션의 경우에는 큐의 size를 변경 하므로 큐의 최대 크기를 저장하는 queSize 전역 변수의 값을 변경해준다.
-p 옵션의 경우에는 log가 생성 되는 위치를 변경해주므로 그 디렉토리가 없다면 생성해주고 그 디렉토리까지의 경로를 curpath에 저장하고 logpath를 p옵션에서 주어진 경로의 아래로 변경해준다.

rMode(): 읽기 모드를 사용했을 때 실행된다. 내부에서 파일을 읽기 모드로 fopen()을 이용해서 열어준뒤 화면에 보여준다. 그리고 화면에 출력이 끝난뒤 파일을 닫아준다.

wMode(): 쓰기 모드를 사용했을 때 호출하는 함수이다. fork()를 이용해서 만든 자식 프로세스에서 execl을 이용해서 /usr/bin/vim을 실행한다. 인자로는 공유파일을 넘겨준다.
-부모 프로세스는 자식 프로세스가 execl을 마치고 종료될 때까지 wait()을 이용해서 대기해준다. 
-만약 옵션 d를 사용했다면 fork() 이전에 임시파일에 내용을 복사해주는데 임시파일의 이름은 tempnam()을 이용해서 만들어준 뒤에 전역 변수 tempName에 저장해준다. 그리고 임시파일에 공유파일을 읽기모드로 열어 모든 내용을 복사해서 임시파일에 써준뒤에 임시파일과 공유 파일을 닫아준다.

check(): ofm으로부터 SIGUSR1을 받을 때까지 기다리는 함수이다.
-공유파일의 절대경로를 만들어준 뒤 FIFO파일을 열어서 공유파일의 정대경로를 적어준다.
-이후 SIGALRM의 핸들러를 등록하고 전역 변수 ofmPid에 getOfmPid()를 이용해서 저장해준뒤 ofm에 SIGUSR1을 보낸다. 만약 ofm이 실행중이 아니라면 ofm이 실행중이 아니라는 메시지와 함께 종료한다.
-이후 confirm변수가 true가 될때까지 while루프를 반복하는데 이때 alarm()과 pause()를 이용해서 1초 간격으로 SIGALRM을 발생시킨다.

getOfmPid(): ofm의 pid를 찾아서 리턴 해주는 함수이다.
-opendir()을 이용해서 /proc밑의 모든 pid를 가져온다.
-해당 pid의 cmdline 파일의 내용에 ./ofm 이 있다면 해당 pid 는 ofm의 pid이므로 그때의 pid를 리턴 해준다. 단 ofm은 단 하나만 진행중이라는 가정하에 가능한 동작이다.
만약 ofm이 없다면 -1을 리턴해준다.

